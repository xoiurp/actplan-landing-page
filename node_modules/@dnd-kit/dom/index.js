import { configurator, Plugin, CorePlugin, Sensor, DragDropManager as DragDropManager$1, Draggable as Draggable$1, descriptor, Droppable as Droppable$1 } from '@dnd-kit/abstract';
import { ScrollDirection, isElement, generateUniqueId, getWindow, isSafari, getDocument, getFrameTransform, DOMRectangle, Styles, getComputedStyles, isKeyboardEvent, parseTranslate, supportsPopover, showPopover, supportsStyle, getFrameElement, animateTransform, cloneElement, ProxiedElements, canScroll, detectScrollIntent, scheduler, getElementFromPoint, getScrollableAncestors, Listeners, scrollIntoViewIfNeeded, isHTMLElement, isPointerEvent, PositionObserver } from '@dnd-kit/dom/utilities';
import { effects, effect, untracked, computed, deepEqual, batch, signal, reactive } from '@dnd-kit/state';
import { Axes, exceedsDistance } from '@dnd-kit/geometry';
import { defaultCollisionDetection } from '@dnd-kit/collision';

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __decoratorStart = (base) => {
  var _a3;
  return [, , , __create((_a3 = base == null ? void 0 : base[__knownSymbol("metadata")]) != null ? _a3 : null)];
};
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// src/core/plugins/accessibility/defaults.ts
var defaultAttributes = {
  role: "button",
  roleDescription: "draggable",
  tabIndex: 0
};
var defaultDescriptionIdPrefix = `dnd-kit-description`;
var defaultAnnouncementIdPrefix = `dnd-kit-announcement`;
var defaultScreenReaderInstructions = {
  draggable: `To pick up a draggable item, press the space bar. While dragging, use the arrow keys to move the item in a given direction. Press space again to drop the item in its new position, or press escape to cancel.`
};
var defaultAnnouncements = {
  dragstart({ operation: { source } }) {
    if (!source) return;
    return `Picked up draggable item ${source.id}.`;
  },
  dragover({ operation: { source, target } }) {
    if (!source) return;
    if (target) {
      return `Draggable item ${source.id} was moved over droppable target ${target.id}.`;
    }
    return `Draggable item ${source.id} is no longer over a droppable target.`;
  },
  dragend({ operation: { source, target }, canceled }) {
    if (!source) return;
    if (canceled) {
      return `Dragging was cancelled. Draggable item ${source.id} was dropped.`;
    }
    if (target) {
      return `Draggable item ${source.id} was dropped over droppable target ${target.id}`;
    }
    return `Draggable item ${source.id} was dropped.`;
  }
};
function isFocusable(element) {
  const window = getWindow(element);
  return element instanceof window.HTMLInputElement || element instanceof window.HTMLSelectElement || element instanceof window.HTMLTextAreaElement || element instanceof window.HTMLAnchorElement || element instanceof window.HTMLButtonElement || element instanceof window.HTMLAreaElement;
}

// src/core/plugins/accessibility/HiddenText.ts
function createHiddenText(id, value) {
  const element = document.createElement("div");
  element.id = id;
  element.style.setProperty("display", "none");
  element.innerText = value;
  return element;
}

// src/core/plugins/accessibility/LiveRegion.ts
function createLiveRegion(id) {
  const element = document.createElement("div");
  element.id = id;
  element.setAttribute("role", "status");
  element.setAttribute("aria-live", "polite");
  element.setAttribute("aria-atomic", "true");
  element.style.setProperty("position", "fixed");
  element.style.setProperty("width", "1px");
  element.style.setProperty("height", "1px");
  element.style.setProperty("margin", "-1px");
  element.style.setProperty("border", "0");
  element.style.setProperty("padding", "0");
  element.style.setProperty("overflow", "hidden");
  element.style.setProperty("clip", "rect(0 0 0 0)");
  element.style.setProperty("clip-path", "inset(100%)");
  element.style.setProperty("white-space", "nowrap");
  return element;
}

// src/core/plugins/accessibility/Accessibility.ts
var Accessibility = class extends Plugin {
  constructor(manager, options) {
    super(manager);
    const {
      id,
      idPrefix: {
        description: descriptionPrefix = defaultDescriptionIdPrefix,
        announcement: announcementPrefix = defaultAnnouncementIdPrefix
      } = {},
      announcements = defaultAnnouncements,
      screenReaderInstructions = defaultScreenReaderInstructions
    } = options != null ? options : {};
    const descriptionId = id ? `${descriptionPrefix}-${id}` : generateUniqueId(descriptionPrefix);
    const announcementId = id ? `${announcementPrefix}-${id}` : generateUniqueId(announcementPrefix);
    let hiddenTextElement;
    let liveRegionElement;
    const eventListeners = Object.entries(announcements).map(
      ([eventName, getAnnouncement]) => {
        return this.manager.monitor.addEventListener(
          eventName,
          (event, manager2) => {
            const announcement = getAnnouncement == null ? void 0 : getAnnouncement(event, manager2);
            if (announcement && liveRegionElement) {
              liveRegionElement.innerText = announcement;
            }
          }
        );
      }
    );
    const initialize = () => {
      hiddenTextElement = createHiddenText(
        descriptionId,
        screenReaderInstructions.draggable
      );
      liveRegionElement = createLiveRegion(announcementId);
      document.body.append(hiddenTextElement, liveRegionElement);
    };
    const cleanupEffects = effects(() => {
      for (const draggable of manager.registry.draggables.value) {
        const { element, handle } = draggable;
        const activator = handle != null ? handle : element;
        const window = getWindow(activator);
        if (activator) {
          if (!hiddenTextElement || !liveRegionElement) {
            initialize();
          }
          if ((!isFocusable(activator) || isSafari()) && !activator.hasAttribute("tabindex")) {
            activator.setAttribute("tabindex", "0");
          }
          if (!activator.hasAttribute("role") && !(activator instanceof window.HTMLButtonElement)) {
            activator.setAttribute("role", defaultAttributes.role);
          }
          if (!activator.hasAttribute("role-description")) {
            activator.setAttribute(
              "aria-roledescription",
              defaultAttributes.roleDescription
            );
          }
          if (!activator.hasAttribute("aria-describedby")) {
            activator.setAttribute("aria-describedby", descriptionId);
          }
          for (const key of ["aria-pressed", "aria-grabbed"]) {
            activator.setAttribute(key, String(draggable.isDragSource));
          }
          activator.setAttribute("aria-disabled", String(draggable.disabled));
        }
      }
      this.destroy = () => {
        hiddenTextElement == null ? void 0 : hiddenTextElement.remove();
        liveRegionElement == null ? void 0 : liveRegionElement.remove();
        eventListeners.forEach((unsubscribe) => unsubscribe());
        cleanupEffects();
      };
    });
  }
};
var Cursor = class extends Plugin {
  constructor(manager, options) {
    super(manager, options);
    this.manager = manager;
    this.destroy = effect(() => {
      var _a3;
      const { dragOperation } = this.manager;
      const { cursor = "grabbing" } = (_a3 = this.options) != null ? _a3 : {};
      if (dragOperation.status.initialized) {
        const style = document.createElement("style");
        style.innerText = `* { cursor: ${cursor} !important; }`;
        document.head.appendChild(style);
        return () => {
          style.remove();
        };
      }
    });
  }
};
var ATTR_PREFIX = "data-dnd-";
var CSS_PREFIX = "--dnd-";
var ATTRIBUTE = `${ATTR_PREFIX}dragging`;
var cssRules = `[${ATTRIBUTE}] {position: fixed !important;pointer-events: none !important;touch-action: none !important;z-index: calc(infinity);will-change: translate;top: var(${CSS_PREFIX}top, 0px) !important;left: var(${CSS_PREFIX}left, 0px) !important;right: unset !important;bottom: unset !important;width: var(${CSS_PREFIX}width, auto) !important;height: var(${CSS_PREFIX}height, auto) !important;box-sizing:border-box;}[${ATTRIBUTE}] *{pointer-events: none !important;}[${ATTRIBUTE}][style*="${CSS_PREFIX}translate"] {translate: var(${CSS_PREFIX}translate) !important;}[style*="${CSS_PREFIX}transition"] {transition: var(${CSS_PREFIX}transition) !important;}*:where([${ATTRIBUTE}][popover]){overflow:visible;background:var(${CSS_PREFIX}background);border:var(${CSS_PREFIX}border);margin:unset;padding:unset;color:inherit;}[${ATTRIBUTE}]::backdrop {display: none}html:has([${ATTRIBUTE}]) * {user-select:none;-webkit-user-select:none;}`;
var PLACEHOLDER_ATTRIBUTE = `${ATTR_PREFIX}placeholder`;
var IGNORED_ATTRIBUTES = [
  ATTRIBUTE,
  PLACEHOLDER_ATTRIBUTE,
  "popover",
  "aria-pressed",
  "aria-grabbing"
];
var IGNORED_STYLES = ["view-transition-name"];
var _Feedback = class _Feedback extends Plugin {
  constructor(manager, options) {
    super(manager);
    const styleTags = /* @__PURE__ */ new Map();
    let initialSize;
    let initialCoordinates;
    let initialFrameTransform;
    let initialTranslate = { x: 0, y: 0 };
    let currentTranslate;
    let transformOrigin;
    let moved = false;
    const styleInjectionCleanup = effect(() => {
      var _a3, _b2;
      const { status, source, target } = manager.dragOperation;
      if (status.initialized) {
        const sourceDocument = getDocument((_a3 = source == null ? void 0 : source.element) != null ? _a3 : null);
        const targetDocument = getDocument((_b2 = target == null ? void 0 : target.element) != null ? _b2 : null);
        const documents = /* @__PURE__ */ new Set([sourceDocument, targetDocument]);
        for (const doc of documents) {
          if (!styleTags.has(doc)) {
            const style = document.createElement("style");
            style.innerText = cssRules;
            doc.head.prepend(style);
            styleTags.set(doc, style);
          }
        }
        return styleInjectionCleanup;
      }
    });
    const cleanupEffect = effect(() => {
      var _a3;
      const { dragOperation } = manager;
      const { position, source, status } = dragOperation;
      if (status.idle) {
        currentTranslate = void 0;
        initialCoordinates = void 0;
        initialSize = void 0;
        initialFrameTransform = void 0;
        initialTranslate = { x: 0, y: 0 };
        transformOrigin = void 0;
        return;
      }
      if (!source) return;
      const { element, feedback } = source;
      if (!element || feedback === "none") {
        return;
      }
      let cleanup;
      const frameTransform = getFrameTransform(element);
      const shape = new DOMRectangle(element, {
        frameTransform: null,
        ignoreTransforms: true
      });
      const { width, height, top, left } = shape;
      const styles = new Styles(element);
      const { background, border, transition, translate } = getComputedStyles(element);
      const clone = feedback === "clone";
      const placeholder = feedback !== "move" ? createPlaceholder(source) : null;
      const isKeyboardOperation = untracked(
        () => isKeyboardEvent(manager.dragOperation.activatorEvent)
      );
      if (translate !== "none") {
        const parsedTranslate = parseTranslate(translate);
        if (parsedTranslate) {
          initialTranslate = parsedTranslate;
        }
      }
      const relativeTop = top * frameTransform.scaleY + frameTransform.y;
      const relativeLeft = left * frameTransform.scaleX + frameTransform.x;
      if (!initialCoordinates) {
        initialCoordinates = { x: relativeLeft, y: relativeTop };
      }
      if (!initialSize) {
        initialSize = { width, height };
      }
      if (!initialFrameTransform) {
        initialFrameTransform = frameTransform;
      }
      if (!transformOrigin) {
        const current = untracked(() => position.current);
        transformOrigin = {
          x: (current.x - left * frameTransform.scaleX - frameTransform.x) / (width * frameTransform.scaleX),
          y: (current.y - top * frameTransform.scaleY - frameTransform.y) / (height * frameTransform.scaleY)
        };
      }
      const coordinatesDelta = {
        x: initialCoordinates.x - relativeLeft,
        y: initialCoordinates.y - relativeTop
      };
      const sizeDelta = {
        width: (initialSize.width * initialFrameTransform.scaleX - width * frameTransform.scaleX) * transformOrigin.x,
        height: (initialSize.height * initialFrameTransform.scaleY - height * frameTransform.scaleY) * transformOrigin.y
      };
      const delta = {
        x: coordinatesDelta.x / frameTransform.scaleX + sizeDelta.width,
        y: coordinatesDelta.y / frameTransform.scaleY + sizeDelta.height
      };
      const projected = {
        left: left + delta.x,
        top: top + delta.y
      };
      element.setAttribute(ATTRIBUTE, "true");
      const transform = untracked(() => dragOperation.transform);
      const translateString = `${transform.x * frameTransform.scaleX + initialTranslate.x}px ${transform.y * frameTransform.scaleY + initialTranslate.y}px 0`;
      styles.set(
        {
          width,
          height,
          top: projected.top,
          left: projected.left,
          background,
          border,
          translate: translateString
        },
        CSS_PREFIX
      );
      if (placeholder) {
        element.insertAdjacentElement("afterend", placeholder);
        if (options == null ? void 0 : options.rootElement) {
          const root = typeof options.rootElement === "function" ? options.rootElement(source) : options.rootElement;
          root.appendChild(element);
        }
      }
      if (supportsPopover(element)) {
        if (!element.hasAttribute("popover")) {
          element.setAttribute("popover", "");
        }
        showPopover(element);
      }
      const actual = new DOMRectangle(element, {
        ignoreTransforms: true
      });
      const offset = {
        top: projected.top - actual.top,
        left: projected.left - actual.left
      };
      if (Math.abs(offset.left) > 0.01 || Math.abs(offset.top) > 0.01) {
        styles.set(
          {
            top: actual.top + offset.top,
            left: actual.left + offset.left
          },
          CSS_PREFIX
        );
      } else {
        offset.left = 0;
        offset.top = 0;
      }
      const resizeObserver = new ResizeObserver(() => {
        if (!placeholder) return;
        const placeholderShape = new DOMRectangle(placeholder, {
          ignoreTransforms: true
        });
        const origin = transformOrigin != null ? transformOrigin : { x: 1, y: 1 };
        const dX = (width - placeholderShape.width) * origin.x + delta.x;
        const dY = (height - placeholderShape.height) * origin.y + delta.y;
        styles.set(
          {
            width: placeholderShape.width,
            height: placeholderShape.height,
            top: top + dY,
            left: left + dX
          },
          CSS_PREFIX
        );
        const window = getWindow(element);
        if (element instanceof window.HTMLTableRowElement && placeholder instanceof window.HTMLTableRowElement) {
          const cells = Array.from(element.cells);
          const placeholderCells = Array.from(placeholder.cells);
          for (const [index, cell] of cells.entries()) {
            const placeholderCell = placeholderCells[index];
            cell.style.width = `${placeholderCell.offsetWidth}px`;
          }
        }
        dragOperation.shape = new DOMRectangle(element);
      });
      dragOperation.shape = new DOMRectangle(element);
      source.status = "dragging";
      let elementMutationObserver;
      let documentMutationObserver;
      if (placeholder) {
        resizeObserver.observe(placeholder);
        elementMutationObserver = new MutationObserver(() => {
          for (const attribute of Array.from(element.attributes)) {
            if (attribute.name.startsWith("aria-") || IGNORED_ATTRIBUTES.includes(attribute.name)) {
              continue;
            }
            if (attribute.name === "style") {
              if (supportsStyle(element) && supportsStyle(placeholder)) {
                placeholder.setAttribute("style", clone ? "" : "opacity: 0;");
                placeholder.style.setProperty("transition", "none");
                for (const key of Object.values(element.style)) {
                  if (key.startsWith(CSS_PREFIX) || IGNORED_STYLES.includes(key)) {
                    continue;
                  }
                  placeholder.style.setProperty(
                    key,
                    element.style.getPropertyValue(key)
                  );
                }
              }
              continue;
            }
            placeholder.setAttribute(attribute.name, attribute.value);
          }
          if (clone) {
            placeholder.innerHTML = element.innerHTML;
          }
        });
        elementMutationObserver.observe(element, {
          attributes: true,
          subtree: true
        });
        documentMutationObserver = new MutationObserver((entries) => {
          for (const entry of entries) {
            const { addedNodes } = entry;
            if (addedNodes.length > 0 && Array.from(addedNodes).some((node) => node.contains(element))) {
              element.insertAdjacentElement("afterend", placeholder);
              showPopover(element);
              return;
            }
          }
        });
        documentMutationObserver.observe(element.ownerDocument.body, {
          childList: true,
          subtree: true
        });
      }
      const cleanupEffect2 = effect(function updateTransform() {
        const { transform: transform2, status: status2 } = dragOperation;
        if (!transform2.x && !transform2.y && !moved) {
          return;
        }
        if (!moved) {
          moved = true;
        }
        if (status2.dragging) {
          const translateTransition = isKeyboardOperation ? "250ms cubic-bezier(0.25, 1, 0.5, 1)" : "0ms linear";
          const x = transform2.x / frameTransform.scaleX + initialTranslate.x;
          const y = transform2.y / frameTransform.scaleY + initialTranslate.y;
          styles.set(
            {
              transition: `${transition}, translate ${translateTransition}`,
              translate: `${x}px ${y}px 0`
            },
            CSS_PREFIX
          );
          dragOperation.shape = new DOMRectangle(element);
          currentTranslate = {
            x,
            y
          };
        }
      });
      const id = (_a3 = manager.dragOperation.source) == null ? void 0 : _a3.id;
      const restoreFocus = () => {
        var _a4;
        if (!isKeyboardOperation || id == null) {
          return;
        }
        const draggable = manager.registry.draggables.get(id);
        const element2 = (_a4 = draggable == null ? void 0 : draggable.handle) != null ? _a4 : draggable == null ? void 0 : draggable.element;
        if (element2 instanceof HTMLElement) {
          element2.focus();
        }
      };
      let dropEffectCleanup;
      cleanup = () => {
        elementMutationObserver == null ? void 0 : elementMutationObserver.disconnect();
        documentMutationObserver == null ? void 0 : documentMutationObserver.disconnect();
        resizeObserver.disconnect();
        styles.reset();
        if (placeholder && (moved || placeholder.parentElement !== element.parentElement) && element.isConnected) {
          placeholder.replaceWith(element);
        }
        placeholder == null ? void 0 : placeholder.remove();
        element.removeAttribute(ATTRIBUTE);
        if (supportsPopover(element)) {
          element.removeAttribute("popover");
        }
        cleanupEffect2();
        dropEffectCleanup == null ? void 0 : dropEffectCleanup();
        source.status = "idle";
        moved = false;
      };
      dropEffectCleanup = effect(function dropAnimation() {
        if (dragOperation.status.dropped) {
          const onComplete = cleanup;
          cleanup = void 0;
          source.status = "dropping";
          const transform2 = currentTranslate;
          if (!transform2) {
            onComplete == null ? void 0 : onComplete();
            return;
          }
          manager.renderer.rendering.then(() => {
            showPopover(element);
            const target = placeholder != null ? placeholder : element;
            const animations = element.getAnimations();
            if (animations.length) {
              animations.forEach((animation) => {
                const { effect: effect9 } = animation;
                if (effect9 instanceof KeyframeEffect) {
                  if (effect9.getKeyframes().some((keyframe) => keyframe.translate)) {
                    animation.finish();
                  }
                }
              });
            }
            const sameFrame = getFrameElement(element) === getFrameElement(target);
            const options2 = {
              frameTransform: sameFrame ? null : void 0
            };
            const current = new DOMRectangle(element, options2);
            const final = new DOMRectangle(target, options2);
            const delta2 = {
              x: current.center.x - final.center.x,
              y: current.center.y - final.center.y
            };
            const finalTransform = {
              x: transform2.x - delta2.x,
              y: transform2.y - delta2.y
            };
            const heightKeyframes = Math.round(current.height) !== Math.round(final.height) ? {
              minHeight: [`${current.height}px`, `${final.height}px`],
              maxHeight: [`${current.height}px`, `${final.height}px`]
            } : {};
            const widthKeyframes = Math.round(current.width) !== Math.round(final.width) ? {
              minWidth: [`${current.width}px`, `${final.width}px`],
              maxWidth: [`${current.width}px`, `${final.width}px`]
            } : {};
            animateTransform({
              element,
              keyframes: __spreadProps(__spreadValues(__spreadValues({}, heightKeyframes), widthKeyframes), {
                translate: [
                  `${transform2.x}px ${transform2.y}px 0`,
                  `${finalTransform.x}px ${finalTransform.y}px 0`
                ]
              }),
              options: {
                duration: moved ? 250 : 0,
                easing: "ease"
              },
              onReady() {
                styles.remove(["translate"], CSS_PREFIX);
              },
              onFinish() {
                requestAnimationFrame(restoreFocus);
                onComplete == null ? void 0 : onComplete();
              }
            });
          });
        }
      });
      return () => cleanup == null ? void 0 : cleanup();
    });
    this.destroy = () => {
      styleInjectionCleanup();
      cleanupEffect();
      styleTags.forEach((style) => style.remove());
    };
  }
};
_Feedback.configure = configurator(_Feedback);
var Feedback = _Feedback;
function createPlaceholder(source) {
  return untracked(() => {
    var _a3;
    const { element, manager } = source;
    if (!element || !manager) return;
    const { droppables } = manager.registry;
    const containedDroppables = /* @__PURE__ */ new Map();
    for (const droppable of droppables) {
      if (!droppable.element) continue;
      if (element === droppable.element || element.contains(droppable.element)) {
        const identifierAttribute = `${ATTR_PREFIX}${generateUniqueId("dom-id")}`;
        droppable.element.setAttribute(identifierAttribute, "");
        containedDroppables.set(droppable, identifierAttribute);
      }
    }
    const cleanup = [];
    const placeholder = cloneElement(element);
    const { remove } = placeholder;
    for (const [droppable, identifierAttribute] of containedDroppables) {
      if (!droppable.element) continue;
      const selector = `[${identifierAttribute}]`;
      const clonedElement = placeholder.matches(selector) ? placeholder : placeholder.querySelector(selector);
      (_a3 = droppable.element) == null ? void 0 : _a3.removeAttribute(identifierAttribute);
      if (!clonedElement) continue;
      let current = droppable.element;
      droppable.proxy = clonedElement;
      clonedElement.removeAttribute(identifierAttribute);
      ProxiedElements.set(current, clonedElement);
      cleanup.push(() => {
        ProxiedElements.delete(current);
        droppable.proxy = void 0;
      });
    }
    placeholder.setAttribute("inert", "true");
    placeholder.setAttribute("tab-index", "-1");
    placeholder.setAttribute("aria-hidden", "true");
    placeholder.setAttribute(PLACEHOLDER_ATTRIBUTE, "");
    placeholder.remove = () => {
      cleanup.forEach((fn) => fn());
      remove.call(placeholder);
    };
    return placeholder;
  });
}
var LOCKED = true;
var UNLOCKED = false;
var _dec, _a, _dec2, _b, _init, __b, __a;
_b = (_dec2 = [reactive], ScrollDirection.Forward), _a = (_dec = [reactive], ScrollDirection.Reverse);
var ScrollLock = class {
  constructor() {
    __privateAdd(this, __b, __runInitializers(_init, 8, this, LOCKED)), __runInitializers(_init, 11, this);
    __privateAdd(this, __a, __runInitializers(_init, 12, this, LOCKED)), __runInitializers(_init, 15, this);
  }
  isLocked(direction) {
    if (direction === ScrollDirection.Idle) {
      return false;
    }
    if (direction == null) {
      return this[ScrollDirection.Forward] === LOCKED && this[ScrollDirection.Reverse] === LOCKED;
    }
    return this[direction] === LOCKED;
  }
  unlock(direction) {
    if (direction === ScrollDirection.Idle) {
      return;
    }
    this[direction] = UNLOCKED;
  }
};
_init = __decoratorStart(null);
__b = new WeakMap();
__a = new WeakMap();
__decorateElement(_init, 4, _b, _dec2, ScrollLock, __b);
__decorateElement(_init, 4, _a, _dec, ScrollLock, __a);
__decoratorMetadata(_init, ScrollLock);

// src/core/plugins/scrolling/ScrollIntent.ts
var DIRECTIONS = [ScrollDirection.Forward, ScrollDirection.Reverse];
var ScrollIntent = class {
  constructor() {
    this.x = new ScrollLock();
    this.y = new ScrollLock();
  }
  isLocked() {
    return this.x.isLocked() && this.y.isLocked();
  }
};
var ScrollIntentTracker = class extends Plugin {
  constructor(manager) {
    super(manager);
    const scrollIntent = signal(new ScrollIntent());
    let previousDelta = null;
    this.signal = scrollIntent;
    effect(() => {
      const { status } = manager.dragOperation;
      if (!status.initialized) {
        previousDelta = null;
        scrollIntent.value = new ScrollIntent();
        return;
      }
      const { delta } = manager.dragOperation.position;
      if (previousDelta) {
        const directions = {
          x: getDirection(delta.x, previousDelta.x),
          y: getDirection(delta.y, previousDelta.y)
        };
        const intent = scrollIntent.peek();
        batch(() => {
          for (const axis of Axes) {
            for (const direction of DIRECTIONS) {
              if (directions[axis] === direction) {
                intent[axis].unlock(direction);
              }
            }
          }
          scrollIntent.value = intent;
        });
      }
      previousDelta = delta;
    });
  }
  get current() {
    return this.signal.peek();
  }
};
function getDirection(a, b) {
  return Math.sign(a - b);
}

// src/core/plugins/scrolling/Scroller.ts
var _autoScrolling_dec, _a2, _init2, _autoScrolling, _meta, _scroll;
var Scroller = class extends (_a2 = CorePlugin, _autoScrolling_dec = [reactive], _a2) {
  constructor(manager) {
    super(manager);
    __privateAdd(this, _autoScrolling, __runInitializers(_init2, 8, this, false)), __runInitializers(_init2, 11, this);
    __privateAdd(this, _meta);
    __privateAdd(this, _scroll, () => {
      if (!__privateGet(this, _meta)) {
        return;
      }
      const { element, by } = __privateGet(this, _meta);
      if (by.y) element.scrollTop += by.y;
      if (by.x) element.scrollLeft += by.x;
    });
    this.scroll = (options) => {
      var _a3;
      if (this.disabled) {
        return false;
      }
      const elements = this.getScrollableElements();
      if (!elements) {
        __privateSet(this, _meta, void 0);
        return false;
      }
      const { position } = this.manager.dragOperation;
      const currentPosition = position == null ? void 0 : position.current;
      if (currentPosition) {
        const { by } = options != null ? options : {};
        const intent = by ? {
          x: getScrollIntent(by.x),
          y: getScrollIntent(by.y)
        } : void 0;
        const scrollIntent = intent ? void 0 : this.scrollIntentTracker.current;
        if (scrollIntent == null ? void 0 : scrollIntent.isLocked()) {
          return false;
        }
        for (const scrollableElement of elements) {
          const elementCanScroll = canScroll(scrollableElement, by);
          if (elementCanScroll.x || elementCanScroll.y) {
            const { speed, direction } = detectScrollIntent(
              scrollableElement,
              currentPosition,
              intent
            );
            if (scrollIntent) {
              for (const axis of Axes) {
                if (scrollIntent[axis].isLocked(direction[axis])) {
                  speed[axis] = 0;
                  direction[axis] = 0;
                }
              }
            }
            if (direction.x || direction.y) {
              const { x, y } = by != null ? by : direction;
              const scrollLeftBy = x * speed.x;
              const scrollTopBy = y * speed.y;
              if (scrollLeftBy || scrollTopBy) {
                const previousScrollBy = (_a3 = __privateGet(this, _meta)) == null ? void 0 : _a3.by;
                if (this.autoScrolling && previousScrollBy) {
                  const scrollIntentMismatch = previousScrollBy.x && !scrollLeftBy || previousScrollBy.y && !scrollTopBy;
                  if (scrollIntentMismatch) continue;
                }
                __privateSet(this, _meta, {
                  element: scrollableElement,
                  by: {
                    x: scrollLeftBy,
                    y: scrollTopBy
                  }
                });
                scheduler.schedule(__privateGet(this, _scroll));
                return true;
              }
            }
          }
        }
      }
      __privateSet(this, _meta, void 0);
      return false;
    };
    let previousElementFromPoint = null;
    let previousScrollableElements = null;
    const elementFromPoint = computed(() => {
      const { position } = manager.dragOperation;
      if (!position) {
        return null;
      }
      const element = getElementFromPoint(document, position.current);
      if (element) {
        previousElementFromPoint = element;
      }
      return element != null ? element : previousElementFromPoint;
    });
    const scrollableElements = computed(() => {
      const element = elementFromPoint.value;
      const { documentElement } = getDocument(element);
      if (!element || element === documentElement) {
        const { target } = manager.dragOperation;
        const targetElement = target == null ? void 0 : target.element;
        if (targetElement) {
          const elements = getScrollableAncestors(targetElement, {
            excludeElement: false
          });
          previousScrollableElements = elements;
          return elements;
        }
      }
      if (element) {
        const elements = getScrollableAncestors(element, {
          excludeElement: false
        });
        if (this.autoScrolling && previousScrollableElements && elements.size < (previousScrollableElements == null ? void 0 : previousScrollableElements.size)) {
          return previousScrollableElements;
        }
        previousScrollableElements = elements;
        return elements;
      }
      previousScrollableElements = null;
      return null;
    }, deepEqual);
    this.getScrollableElements = () => {
      return scrollableElements.value;
    };
    this.scrollIntentTracker = new ScrollIntentTracker(manager);
    this.destroy = manager.monitor.addEventListener("dragmove", (event) => {
      if (this.disabled || event.defaultPrevented || !isKeyboardEvent(manager.dragOperation.activatorEvent) || !event.by) {
        return;
      }
      if (this.scroll({ by: event.by })) {
        event.preventDefault();
      }
    });
  }
};
_init2 = __decoratorStart(_a2);
_autoScrolling = new WeakMap();
_meta = new WeakMap();
_scroll = new WeakMap();
__decorateElement(_init2, 4, "autoScrolling", _autoScrolling_dec, Scroller, _autoScrolling);
__decoratorMetadata(_init2, Scroller);
function getScrollIntent(value) {
  if (value > 0) {
    return ScrollDirection.Forward;
  }
  if (value < 0) {
    return ScrollDirection.Reverse;
  }
  return ScrollDirection.Idle;
}
var AUTOSCROLL_INTERVAL = 10;
var AutoScroller = class extends Plugin {
  constructor(manager, _options) {
    super(manager);
    const scroller = manager.registry.plugins.get(Scroller);
    if (!scroller) {
      throw new Error("AutoScroller plugin depends on Scroller plugin");
    }
    this.destroy = effect(() => {
      if (this.disabled) {
        return;
      }
      const { position: _, status } = manager.dragOperation;
      if (status.dragging) {
        const canScroll2 = scroller.scroll();
        if (canScroll2) {
          scroller.autoScrolling = true;
          const interval = setInterval(scroller.scroll, AUTOSCROLL_INTERVAL);
          return () => {
            clearInterval(interval);
          };
        } else {
          scroller.autoScrolling = false;
        }
      }
    });
  }
};
var listenerOptions = {
  capture: true,
  passive: true
};
var _timeout;
var ScrollListener = class extends CorePlugin {
  constructor(manager) {
    super(manager);
    __privateAdd(this, _timeout);
    this.handleScroll = () => {
      if (__privateGet(this, _timeout) == null) {
        __privateSet(this, _timeout, setTimeout(() => {
          this.manager.collisionObserver.forceUpdate(false);
          __privateSet(this, _timeout, void 0);
        }, 50));
      }
    };
    const { dragOperation } = this.manager;
    this.destroy = effect(() => {
      var _a3, _b2, _c3;
      const enabled = dragOperation.status.dragging;
      if (enabled) {
        const root = (_c3 = (_b2 = (_a3 = dragOperation.source) == null ? void 0 : _a3.element) == null ? void 0 : _b2.ownerDocument) != null ? _c3 : document;
        root.addEventListener("scroll", this.handleScroll, listenerOptions);
        return () => {
          root.removeEventListener(
            "scroll",
            this.handleScroll,
            listenerOptions
          );
        };
      }
    });
  }
};
_timeout = new WeakMap();
var PreventSelection = class extends Plugin {
  constructor(manager) {
    super(manager);
    this.manager = manager;
    this.destroy = effect(() => {
      const { dragOperation } = this.manager;
      if (dragOperation.status.initialized) {
        const style = document.createElement("style");
        style.innerText = `* { user-select: none !important;, -webkit-user-select: none !important; }`;
        document.head.appendChild(style);
        document.addEventListener("selectionchange", removeSelection, {
          capture: true
        });
        return () => {
          document.removeEventListener("selectionchange", removeSelection, {
            capture: true
          });
          style.remove();
        };
      }
    });
  }
};
function removeSelection() {
  var _a3;
  (_a3 = document.getSelection()) == null ? void 0 : _a3.removeAllRanges();
}
var DEFAULT_KEYBOARD_CODES = {
  start: ["Space", "Enter"],
  cancel: ["Escape"],
  end: ["Space", "Enter", "Tab"],
  up: ["ArrowUp"],
  down: ["ArrowDown"],
  left: ["ArrowLeft"],
  right: ["ArrowRight"]
};
var DEFAULT_OFFSET = 10;
var _cleanupFunctions;
var KeyboardSensor = class extends Sensor {
  constructor(manager, options) {
    super(manager);
    this.manager = manager;
    this.options = options;
    __privateAdd(this, _cleanupFunctions, []);
    this.listeners = new Listeners();
    this.handleSourceKeyDown = (event, source, options) => {
      if (this.disabled || event.defaultPrevented) {
        return;
      }
      if (!isElement(event.target)) {
        return;
      }
      if (source.disabled) {
        return;
      }
      if (!source.handle && source.element && event.target === source.element || source.handle && event.target === source.handle) {
        const { keyboardCodes = DEFAULT_KEYBOARD_CODES } = options != null ? options : {};
        if (!keyboardCodes.start.includes(event.code)) {
          return;
        }
        if (!this.manager.dragOperation.status.idle) {
          return;
        }
        this.handleStart(event, source, options);
      }
    };
  }
  bind(source, options = this.options) {
    const unbind = effect(() => {
      var _a3;
      const target = (_a3 = source.handle) != null ? _a3 : source.element;
      const listener = (event) => {
        if (isKeyboardEvent(event)) {
          this.handleSourceKeyDown(event, source, options);
        }
      };
      if (target) {
        target.addEventListener("keydown", listener);
        return () => {
          target.removeEventListener("keydown", listener);
        };
      }
    });
    return unbind;
  }
  handleStart(event, source, options) {
    const { element } = source;
    if (!element) {
      throw new Error("Source draggable does not have an associated element");
    }
    event.preventDefault();
    event.stopImmediatePropagation();
    scrollIntoViewIfNeeded(element);
    const { center } = new DOMRectangle(element);
    batch(() => {
      this.manager.actions.setDragSource(source.id);
      this.manager.actions.start({
        event,
        coordinates: {
          x: center.x,
          y: center.y
        }
      });
    });
    this.sideEffects();
    const sourceDocument = getDocument(element);
    const sourceWindow = getWindow(sourceDocument);
    const listeners = [
      this.listeners.bind(sourceDocument, [
        {
          type: "keydown",
          listener: (event2) => this.handleKeyDown(event2, source, options),
          options: { capture: true }
        }
      ]),
      this.listeners.bind(sourceWindow, [
        { type: "resize", listener: () => this.handleEnd(true) }
      ])
    ];
    __privateGet(this, _cleanupFunctions).push(...listeners);
  }
  handleKeyDown(event, _source, options) {
    const { keyboardCodes = DEFAULT_KEYBOARD_CODES } = options != null ? options : {};
    if (isKeycode(event, [...keyboardCodes.end, ...keyboardCodes.cancel])) {
      event.preventDefault();
      const canceled = isKeycode(event, keyboardCodes.cancel);
      this.handleEnd(canceled);
      return;
    }
    if (isKeycode(event, keyboardCodes.up)) {
      this.handleMove("up", event);
    } else if (isKeycode(event, keyboardCodes.down)) {
      this.handleMove("down", event);
    }
    if (isKeycode(event, keyboardCodes.left)) {
      this.handleMove("left", event);
    } else if (isKeycode(event, keyboardCodes.right)) {
      this.handleMove("right", event);
    }
  }
  handleEnd(canceled) {
    this.manager.actions.stop({
      canceled
    });
    this.cleanup();
  }
  handleMove(direction, event) {
    const { shape } = this.manager.dragOperation;
    const factor = event.shiftKey ? 5 : 1;
    let offset = {
      x: 0,
      y: 0
    };
    if (!shape) {
      return;
    }
    switch (direction) {
      case "up":
        offset = { x: 0, y: -DEFAULT_OFFSET * factor };
        break;
      case "down":
        offset = { x: 0, y: DEFAULT_OFFSET * factor };
        break;
      case "left":
        offset = { x: -DEFAULT_OFFSET * factor, y: 0 };
        break;
      case "right":
        offset = { x: DEFAULT_OFFSET * factor, y: 0 };
        break;
    }
    if ((offset == null ? void 0 : offset.x) || (offset == null ? void 0 : offset.y)) {
      event.preventDefault();
      this.manager.actions.move({
        by: offset
      });
    }
  }
  sideEffects() {
    const autoScroller = this.manager.registry.plugins.get(AutoScroller);
    if ((autoScroller == null ? void 0 : autoScroller.disabled) === false) {
      autoScroller.disable();
      __privateGet(this, _cleanupFunctions).push(() => {
        autoScroller.enable();
      });
    }
  }
  cleanup() {
    __privateGet(this, _cleanupFunctions).forEach((cleanup) => cleanup());
  }
  destroy() {
    this.cleanup();
    this.listeners.clear();
  }
};
_cleanupFunctions = new WeakMap();
function isKeycode(event, codes) {
  return codes.includes(event.code);
}
var _clearTimeout;
var _PointerSensor = class _PointerSensor extends Sensor {
  constructor(manager, options) {
    super(manager);
    this.manager = manager;
    this.options = options;
    this.listeners = new Listeners();
    this.cleanup = /* @__PURE__ */ new Set();
    __privateAdd(this, _clearTimeout);
    this.handleCancel = this.handleCancel.bind(this);
    this.handlePointerUp = this.handlePointerUp.bind(this);
    this.handleKeyDown = this.handleKeyDown.bind(this);
  }
  bind(source, options = this.options) {
    const unbind = effect(() => {
      var _a3;
      const target = (_a3 = source.handle) != null ? _a3 : source.element;
      const listener = (event) => {
        if (isPointerEvent(event)) {
          this.handlePointerDown(event, source, options);
        }
      };
      if (target) {
        patchWindow(target.ownerDocument.defaultView);
        target.addEventListener("pointerdown", listener);
        return () => {
          target.removeEventListener("pointerdown", listener);
        };
      }
    });
    return unbind;
  }
  handlePointerDown(event, source, options = {}) {
    if (this.disabled || !event.isPrimary || event.button !== 0 || !isElement(event.target) || source.disabled || isCapturedBySensor(event)) {
      return;
    }
    const { target } = event;
    const isNativeDraggable = isHTMLElement(target) && target.draggable && target.getAttribute("draggable") === "true";
    const offset = getFrameTransform(source.element);
    this.initialCoordinates = {
      x: event.clientX * offset.scaleX + offset.x,
      y: event.clientY * offset.scaleY + offset.y
    };
    const { activationConstraints } = options;
    const constraints = typeof activationConstraints === "function" ? activationConstraints(event, source) : activationConstraints;
    event.sensor = this;
    if (!(constraints == null ? void 0 : constraints.delay) && !(constraints == null ? void 0 : constraints.distance)) {
      this.handleStart(source, event);
    } else {
      const { delay } = constraints;
      if (delay) {
        const timeout = setTimeout(
          () => this.handleStart(source, event),
          delay.value
        );
        __privateSet(this, _clearTimeout, () => {
          clearTimeout(timeout);
          __privateSet(this, _clearTimeout, void 0);
        });
      }
    }
    const ownerDocument = getDocument(event.target);
    const unbindListeners = this.listeners.bind(ownerDocument, [
      {
        type: "pointermove",
        listener: (event2) => this.handlePointerMove(event2, source, options)
      },
      {
        type: "pointerup",
        listener: this.handlePointerUp,
        options: {
          capture: true
        }
      },
      {
        // Cancel activation if there is a competing Drag and Drop interaction
        type: "dragstart",
        listener: isNativeDraggable ? this.handleCancel : preventDefault
      }
    ]);
    const cleanup = () => {
      var _a3;
      setTimeout(unbindListeners);
      (_a3 = __privateGet(this, _clearTimeout)) == null ? void 0 : _a3.call(this);
      this.initialCoordinates = void 0;
    };
    this.cleanup.add(cleanup);
  }
  handlePointerMove(event, source, options) {
    const coordinates = {
      x: event.clientX,
      y: event.clientY
    };
    const offset = getFrameTransform(source.element);
    coordinates.x = coordinates.x * offset.scaleX + offset.x;
    coordinates.y = coordinates.y * offset.scaleY + offset.y;
    if (this.manager.dragOperation.status.dragging) {
      event.preventDefault();
      event.stopPropagation();
      this.manager.actions.move({ to: coordinates });
      return;
    }
    if (!this.initialCoordinates) {
      return;
    }
    const delta = {
      x: coordinates.x - this.initialCoordinates.x,
      y: coordinates.y - this.initialCoordinates.y
    };
    const { activationConstraints } = options;
    const constraints = typeof activationConstraints === "function" ? activationConstraints(event, source) : activationConstraints;
    const { distance, delay } = constraints != null ? constraints : {};
    if (distance) {
      if (distance.tolerance != null && exceedsDistance(delta, distance.tolerance)) {
        return this.handleCancel();
      }
      if (exceedsDistance(delta, distance.value)) {
        return this.handleStart(source, event);
      }
    }
    if (delay) {
      if (exceedsDistance(delta, delay.tolerance)) {
        return this.handleCancel();
      }
    }
  }
  handlePointerUp(event) {
    const { status } = this.manager.dragOperation;
    if (!status.idle) {
      event.preventDefault();
      event.stopPropagation();
      const canceled = !status.initialized;
      this.manager.actions.stop({ canceled });
    }
    this.cleanup.forEach((cleanup) => cleanup());
    this.cleanup.clear();
  }
  handleKeyDown(event) {
    if (event.key === "Escape") {
      event.preventDefault();
      this.handleCancel();
    }
  }
  handleStart(source, event) {
    var _a3;
    const { manager, initialCoordinates } = this;
    (_a3 = __privateGet(this, _clearTimeout)) == null ? void 0 : _a3.call(this);
    if (!initialCoordinates || manager.dragOperation.status.initialized) {
      return;
    }
    if (event.defaultPrevented) {
      return;
    }
    event.preventDefault();
    batch(() => {
      manager.actions.setDragSource(source.id);
      manager.actions.start({ coordinates: initialCoordinates, event });
    });
    const ownerDocument = getDocument(event.target);
    const unbind = this.listeners.bind(ownerDocument, [
      {
        // Prevent scrolling on touch devices
        type: "touchmove",
        listener: preventDefault,
        options: {
          passive: false
        }
      },
      {
        // Prevent click events
        type: "click",
        listener: preventDefault
      },
      {
        type: "keydown",
        listener: this.handleKeyDown
      }
    ]);
    ownerDocument.body.setPointerCapture(event.pointerId);
    this.cleanup.add(unbind);
  }
  handleCancel() {
    const { dragOperation } = this.manager;
    if (dragOperation.status.initialized) {
      this.manager.actions.stop({ canceled: true });
    }
    this.cleanup.forEach((cleanup) => cleanup());
    this.cleanup.clear();
  }
  destroy() {
    this.listeners.clear();
  }
};
_clearTimeout = new WeakMap();
_PointerSensor.configure = configurator(_PointerSensor);
var PointerSensor = _PointerSensor;
function isCapturedBySensor(event) {
  return "sensor" in event;
}
function preventDefault(event) {
  event.preventDefault();
}
function noop() {
}
var windows = /* @__PURE__ */ new WeakSet();
function patchWindow(window) {
  if (!window || windows.has(window)) {
    return;
  }
  window.addEventListener("touchmove", noop, {
    capture: false,
    passive: false
  });
  windows.add(window);
}

// src/core/manager/manager.ts
var defaultPreset = {
  modifiers: [],
  plugins: [Accessibility, AutoScroller, Cursor, Feedback, PreventSelection],
  sensors: [
    PointerSensor.configure({
      activationConstraints(event, source) {
        var _a3;
        const { pointerType, target } = event;
        if (pointerType === "mouse" && isElement(target) && (source.handle === target || ((_a3 = source.handle) == null ? void 0 : _a3.contains(target)))) {
          return void 0;
        }
        return {
          delay: { value: 200, tolerance: 10 },
          distance: { value: 5 }
        };
      }
    }),
    KeyboardSensor
  ]
};
var DragDropManager = class extends DragDropManager$1 {
  constructor(input = {}) {
    const {
      plugins = defaultPreset.plugins,
      sensors = defaultPreset.sensors,
      modifiers = []
    } = input;
    super(__spreadProps(__spreadValues({}, input), {
      plugins: [ScrollListener, Scroller, ...plugins],
      sensors,
      modifiers
    }));
  }
};
var _feedback_dec, _element_dec, _handle_dec, _c, _init3, _handle, _element, _feedback;
var Draggable = class extends (_c = Draggable$1, _handle_dec = [reactive], _element_dec = [reactive], _feedback_dec = [reactive], _c) {
  constructor(_a3, manager) {
    var _b2 = _a3, {
      element,
      effects: effects2 = () => [],
      handle,
      feedback = "default"
    } = _b2, input = __objRest(_b2, [
      "element",
      "effects",
      "handle",
      "feedback"
    ]);
    super(
      __spreadValues({
        effects: () => [
          ...effects2(),
          () => {
            var _a4, _b3;
            const { manager: manager2 } = this;
            if (!manager2) return;
            const sensors = (_b3 = (_a4 = this.sensors) == null ? void 0 : _a4.map(descriptor)) != null ? _b3 : [
              ...manager2.sensors
            ];
            const unbindFunctions = sensors.map((entry) => {
              const sensorInstance = entry instanceof Sensor ? entry : manager2.registry.register(entry.plugin);
              const options = entry instanceof Sensor ? void 0 : entry.options;
              const unbind = sensorInstance.bind(this, options);
              return unbind;
            });
            return function cleanup() {
              unbindFunctions.forEach((unbind) => unbind());
            };
          }
        ]
      }, input),
      manager
    );
    __privateAdd(this, _handle, __runInitializers(_init3, 8, this)), __runInitializers(_init3, 11, this);
    __privateAdd(this, _element, __runInitializers(_init3, 12, this)), __runInitializers(_init3, 15, this);
    __privateAdd(this, _feedback, __runInitializers(_init3, 16, this)), __runInitializers(_init3, 19, this);
    this.element = element;
    this.handle = handle;
    this.feedback = feedback;
  }
};
_init3 = __decoratorStart(_c);
_handle = new WeakMap();
_element = new WeakMap();
_feedback = new WeakMap();
__decorateElement(_init3, 4, "handle", _handle_dec, Draggable, _handle);
__decorateElement(_init3, 4, "element", _element_dec, Draggable, _element);
__decorateElement(_init3, 4, "feedback", _feedback_dec, Draggable, _feedback);
__decoratorMetadata(_init3, Draggable);
var _proxy_dec, _element_dec2, _c2, _init4, _element2, _d, element_get, element_set, _Droppable_instances, _proxy;
var Droppable = class extends (_c2 = Droppable$1, _element_dec2 = [reactive], _proxy_dec = [reactive], _c2) {
  constructor(_a3, manager) {
    var _b2 = _a3, { element, effects: effects2 = () => [] } = _b2, input = __objRest(_b2, ["element", "effects"]);
    const { collisionDetector = defaultCollisionDetection } = input;
    const updateShape = (boundingClientRect) => {
      const { manager: manager2, element: element2 } = this;
      if (!element2 || boundingClientRect === null) {
        this.shape = void 0;
        return void 0;
      }
      if (!manager2) return;
      const updatedShape = new DOMRectangle(element2);
      const shape = untracked(() => this.shape);
      if (updatedShape && (shape == null ? void 0 : shape.equals(updatedShape))) {
        return shape;
      }
      this.shape = updatedShape;
      return updatedShape;
    };
    const observePosition = signal(false);
    super(
      __spreadProps(__spreadValues({}, input), {
        collisionDetector,
        effects: () => [
          ...effects2(),
          () => {
            const { element: element2, manager: manager2 } = this;
            if (!manager2) return;
            const { dragOperation } = manager2;
            const { source } = dragOperation;
            observePosition.value = Boolean(
              source && dragOperation.status.initialized && element2 && !this.disabled && this.accepts(source)
            );
          },
          () => {
            const { element: element2 } = this;
            if (observePosition.value && element2) {
              const positionObserver = new PositionObserver(
                element2,
                updateShape
              );
              return () => {
                positionObserver.disconnect();
                this.shape = void 0;
              };
            }
          },
          () => {
            var _a4;
            if ((_a4 = this.manager) == null ? void 0 : _a4.dragOperation.status.initialized) {
              return () => {
                this.shape = void 0;
              };
            }
          }
        ]
      }),
      manager
    );
    __privateAdd(this, _Droppable_instances);
    __privateAdd(this, _element2, __runInitializers(_init4, 8, this)), __runInitializers(_init4, 11, this);
    __privateAdd(this, _proxy, __runInitializers(_init4, 12, this)), __runInitializers(_init4, 15, this);
    this.element = element;
    this.refreshShape = () => updateShape();
  }
  set element(element) {
    __privateSet(this, _Droppable_instances, element, element_set);
  }
  get element() {
    var _a3;
    return (_a3 = this.proxy) != null ? _a3 : __privateGet(this, _Droppable_instances, element_get);
  }
};
_init4 = __decoratorStart(_c2);
_element2 = new WeakMap();
_Droppable_instances = new WeakSet();
_proxy = new WeakMap();
_d = __decorateElement(_init4, 20, "#element", _element_dec2, _Droppable_instances, _element2), element_get = _d.get, element_set = _d.set;
__decorateElement(_init4, 4, "proxy", _proxy_dec, Droppable, _proxy);
__decoratorMetadata(_init4, Droppable);

export { Accessibility, AutoScroller, DragDropManager, Draggable, Droppable, Feedback, KeyboardSensor, PointerSensor, ScrollListener, Scroller, defaultPreset };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map