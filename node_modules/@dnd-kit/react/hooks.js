import { useRef, useLayoutEffect, useEffect, useMemo, useState } from 'react';
import { computed, effect } from '@dnd-kit/state';
import { flushSync } from 'react-dom';
import { currentValue } from '@dnd-kit/react/utilities';

function useConstant(initializer) {
  const ref = useRef(null);
  if (!ref.current) {
    ref.current = initializer();
  }
  return ref.current;
}
var canUseDOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var useIsomorphicLayoutEffect = canUseDOM ? useLayoutEffect : useEffect;

// src/hooks/useSignal.ts
function useSignal(signal, sync = false) {
  let val = signal.peek();
  const read = useRef(false);
  const update = useState(val)[1];
  useIsomorphicLayoutEffect(
    () => effect(() => {
      if (val !== (val = signal.value)) {
        if (!read.current) return;
        if (sync) {
          flushSync(() => update(val));
        } else {
          update(val);
        }
      }
    }),
    [signal, sync]
  );
  return {
    get value() {
      read.current = true;
      return signal.value;
    }
  };
}

// src/hooks/useComputed.ts
function useComputed(compute, dependencies = [], sync = false) {
  const $compute = useRef(compute);
  $compute.current = compute;
  return useSignal(
    useMemo(() => computed(() => $compute.current()), dependencies),
    sync
  );
}

// src/hooks/useImmediateEffect.ts
function useImmediateEffect(callback, _) {
  callback();
}
function useLatest(value) {
  const valueRef = useRef(value);
  useIsomorphicLayoutEffect(() => {
    valueRef.current = value;
  }, [value]);
  return valueRef;
}
function useOnValueChange(value, onChange, effect2 = useEffect, compare = Object.is) {
  const tracked = useRef(value);
  effect2(() => {
    const oldValue = tracked.current;
    if (!compare(value, oldValue)) {
      tracked.current = value;
      onChange(value, oldValue);
    }
  }, [onChange, value]);
}
function useOnElementChange(value, onChange) {
  const previous = useRef(currentValue(value));
  useIsomorphicLayoutEffect(() => {
    const current = currentValue(value);
    if (current !== previous.current) {
      previous.current = current;
      onChange(current);
    }
  });
}

export { useComputed, useConstant, useImmediateEffect, useIsomorphicLayoutEffect, useLatest, useOnElementChange, useOnValueChange };
//# sourceMappingURL=hooks.js.map
//# sourceMappingURL=hooks.js.map