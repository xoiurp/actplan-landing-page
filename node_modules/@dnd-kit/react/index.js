import { createContext, useState, useEffect, startTransition, useContext, useCallback, useTransition, useRef, useLayoutEffect } from 'react';
import { DragDropManager, defaultPreset, Draggable, Droppable } from '@dnd-kit/dom';
import { useLatest, useOnValueChange, useIsomorphicLayoutEffect, useComputed, useOnElementChange, useConstant } from '@dnd-kit/react/hooks';
import { deepEqual } from '@dnd-kit/state';
import { jsx } from 'react/jsx-runtime';
import { currentValue } from '@dnd-kit/react/utilities';

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var defaultManager = new DragDropManager();
var DragDropContext = createContext(
  defaultManager
);
function useRenderer() {
  const [_, startTransition2] = useTransition();
  const [transitionCount, setTransitionCount] = useState(0);
  const rendering = useRef(null);
  const resolver = useRef(null);
  const renderer = useConstant(() => ({
    get rendering() {
      var _a;
      return (_a = rendering.current) != null ? _a : Promise.resolve();
    }
  }));
  useOnValueChange(
    transitionCount,
    () => {
      var _a;
      (_a = resolver.current) == null ? void 0 : _a.call(resolver);
      rendering.current = null;
    },
    useLayoutEffect
  );
  return {
    renderer,
    trackRendering(callback) {
      if (!rendering.current) {
        rendering.current = new Promise((resolve) => {
          resolver.current = resolve;
        });
      }
      startTransition2(() => {
        callback();
        setTransitionCount((count) => count + 1);
      });
    }
  };
}
var options = [void 0, deepEqual];
function DragDropProvider(_a) {
  var _b = _a, {
    children,
    onCollision,
    onBeforeDragStart,
    onDragStart,
    onDragMove,
    onDragOver,
    onDragEnd
  } = _b, input = __objRest(_b, [
    "children",
    "onCollision",
    "onBeforeDragStart",
    "onDragStart",
    "onDragMove",
    "onDragOver",
    "onDragEnd"
  ]);
  var _a2;
  const { renderer, trackRendering } = useRenderer();
  const [manager, setManager] = useState(
    (_a2 = input.manager) != null ? _a2 : null
  );
  const { plugins, modifiers, sensors } = input;
  const handleBeforeDragStart = useLatest(onBeforeDragStart);
  const handleDragStart = useLatest(onDragStart);
  const handleDragOver = useLatest(onDragOver);
  const handleDragMove = useLatest(onDragMove);
  const handleDragEnd = useLatest(onDragEnd);
  const handleCollision = useLatest(onCollision);
  useEffect(() => {
    var _a3;
    const manager2 = (_a3 = input.manager) != null ? _a3 : new DragDropManager(input);
    manager2.renderer = renderer;
    manager2.monitor.addEventListener("beforedragstart", (event, manager3) => {
      const callback = handleBeforeDragStart.current;
      if (callback) {
        trackRendering(() => callback(event, manager3));
      }
    });
    manager2.monitor.addEventListener(
      "dragstart",
      (event, manager3) => {
        var _a4;
        return (_a4 = handleDragStart.current) == null ? void 0 : _a4.call(handleDragStart, event, manager3);
      }
    );
    manager2.monitor.addEventListener("dragover", (event, manager3) => {
      const callback = handleDragOver.current;
      if (callback) {
        trackRendering(() => callback(event, manager3));
      }
    });
    manager2.monitor.addEventListener("dragmove", (event, manager3) => {
      const callback = handleDragMove.current;
      if (callback) {
        trackRendering(() => callback(event, manager3));
      }
    });
    manager2.monitor.addEventListener("dragend", (event, manager3) => {
      const callback = handleDragEnd.current;
      if (callback) {
        trackRendering(() => callback(event, manager3));
      }
    });
    manager2.monitor.addEventListener(
      "collision",
      (event, manager3) => {
        var _a4;
        return (_a4 = handleCollision.current) == null ? void 0 : _a4.call(handleCollision, event, manager3);
      }
    );
    startTransition(() => setManager(manager2));
    return manager2.destroy;
  }, [renderer, input.manager]);
  useOnValueChange(
    plugins,
    () => manager && (manager.plugins = plugins != null ? plugins : defaultPreset.plugins),
    ...options
  );
  useOnValueChange(
    sensors,
    () => manager && (manager.sensors = sensors != null ? sensors : defaultPreset.sensors),
    ...options
  );
  useOnValueChange(
    modifiers,
    () => manager && (manager.modifiers = modifiers != null ? modifiers : defaultPreset.modifiers),
    ...options
  );
  return /* @__PURE__ */ jsx(DragDropContext.Provider, { value: manager, children });
}
function useDragDropManager() {
  return useContext(DragDropContext);
}

// src/core/hooks/useInstance.ts
function useInstance(initializer) {
  var _a;
  const manager = (_a = useDragDropManager()) != null ? _a : void 0;
  const [instance] = useState(() => initializer(void 0));
  if (instance.manager !== manager) {
    instance.manager = manager;
  }
  useIsomorphicLayoutEffect(instance.register, [manager, instance]);
  return instance;
}

// src/core/draggable/useDraggable.ts
function useDraggable(input) {
  const { disabled, data, element, handle, id, modifiers, sensors } = input;
  const draggable = useInstance(
    (manager) => new Draggable(
      __spreadProps(__spreadValues({}, input), {
        handle: currentValue(handle),
        element: currentValue(element)
      }),
      manager
    )
  );
  const isDragSource = useComputed(() => draggable.isDragSource, [draggable]);
  const status = useComputed(() => draggable.status, [draggable]);
  useOnValueChange(id, () => draggable.id = id);
  useOnElementChange(handle, (handle2) => draggable.handle = handle2);
  useOnElementChange(element, (element2) => draggable.element = element2);
  useOnValueChange(data, () => data && (draggable.data = data));
  useOnValueChange(disabled, () => draggable.disabled = disabled === true);
  useOnValueChange(sensors, () => draggable.sensors = sensors);
  useOnValueChange(
    modifiers,
    () => draggable.modifiers = modifiers,
    void 0,
    deepEqual
  );
  useOnValueChange(
    input.feedback,
    () => {
      var _a;
      return draggable.feedback = (_a = input.feedback) != null ? _a : "default";
    }
  );
  return {
    draggable,
    get isDragSource() {
      return isDragSource.value;
    },
    get status() {
      return status.value;
    },
    handleRef: useCallback(
      (element2) => {
        draggable.handle = element2 != null ? element2 : void 0;
      },
      [draggable]
    ),
    ref: useCallback(
      (element2) => {
        var _a, _b;
        if (!element2 && ((_a = draggable.element) == null ? void 0 : _a.isConnected) && !((_b = draggable.manager) == null ? void 0 : _b.dragOperation.status.idle)) {
          return;
        }
        draggable.element = element2 != null ? element2 : void 0;
      },
      [draggable]
    )
  };
}
function useDroppable(input) {
  const { collisionDetector, data, disabled, element, id, accept, type } = input;
  const droppable = useInstance(
    (manager) => new Droppable(
      __spreadProps(__spreadValues({}, input), {
        element: currentValue(element)
      }),
      manager
    )
  );
  const isDropTarget = useComputed(() => droppable.isDropTarget, [droppable]);
  useOnValueChange(id, () => droppable.id = id);
  useOnElementChange(element, (element2) => droppable.element = element2);
  useOnValueChange(accept, () => droppable.id = id, void 0, deepEqual);
  useOnValueChange(collisionDetector, () => droppable.id = id);
  useOnValueChange(data, () => data && (droppable.data = data));
  useOnValueChange(disabled, () => droppable.disabled = disabled === true);
  useOnValueChange(type, () => droppable.id = id);
  return {
    get isDropTarget() {
      return isDropTarget.value;
    },
    ref: useCallback(
      (element2) => {
        var _a, _b;
        if (!element2 && ((_a = droppable.element) == null ? void 0 : _a.isConnected) && !((_b = droppable.manager) == null ? void 0 : _b.dragOperation.status.idle)) {
          return;
        }
        droppable.element = element2 != null ? element2 : void 0;
      },
      [droppable]
    ),
    droppable
  };
}
function useDragOperation() {
  const manager = useDragDropManager();
  const source = useComputed(() => manager == null ? void 0 : manager.dragOperation.source, [manager]);
  const target = useComputed(() => manager == null ? void 0 : manager.dragOperation.target, [manager]);
  return {
    get source() {
      return source.value;
    },
    get target() {
      return target.value;
    }
  };
}

export { DragDropProvider, useDragDropManager, useDragOperation, useDraggable, useDroppable, useInstance };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map